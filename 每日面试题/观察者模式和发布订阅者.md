### 观察者模式

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/567e4179118647d59f000763a3bc5046~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

观察者模式至少有一个可被观察的对象，可以有多个观察者去观察这个对象。二者的关系使用过**被观察者**主动建立的。被观察者至少有三个方法 —— 添加观察者，删除观察者，通知观察者。

当观察者被加入列表后，两者的关系达成。观察着只要在某些情况，触发通知观察者的方法。观察者就能接受来自被观察者的信息了。

举例：vue的响应式，被观察者为响应式的数据，观察者为用到数据的依赖函数。响应式会收集依赖函数，并在数据发生变化时触发依赖函数的更新。

~~~js
// 被观察者
class Subject {
  constructor() {
    this.observerList = []
  }

  addObserver(observer) {
    this.observerList.push(observer)
  }

  removeObserverList(observer) {
    const index = this.observerList.findIndex(o => o.name = observer.name) 
    this.observerList.splice(index, 1)
  }

  notifyObservers(message) {
    const observers = this.observerList
    observers.forEach(o => {
      o.notified(message)
    })
  }
}

// 观察者
class Observer {
  constructor(name, subject) {
    this.name = name
    if (subject) {
      subject.addObserverList(this)
    }
  }
  notified(message) {
    console.log(this.name, 'got message', message);
  }
}

// 使用
const subject = new Subject();
const observerA = new Observer('observerA', subject);
const observerB = new Observer('observerB');
subject.addObserver(observerB);
subject.notifyObservers('Hello from subject');
subject.removeObserver(observerA);
subject.notifyObservers('Hello again');
~~~

### 发布订阅者

<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19b670df6cb54c4ebdc17a114b5dc97c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">

理解为邮件系统，你可以作为订阅者订阅某个网站，邮件作为发布订阅中心，网站作为发布者。
以邮件系统为中心，发布的时候在邮件中记录网站信息，后续当网站内容更新，邮件系统会接受发布者的消息，并通知订阅者。

~~~js
// 发布订阅中心
clase PubSub {
  constructor {
    this.message = {}
    this.listener = {}
  }
  publish(type, content) {
    const existContents = this.message[type]
    if (!existContents) {
      this.message[type] = []
    }
    this.message[type].push(content)
  }
  subscribe(type, cb) {
    const existListeners = this.message[type]
    if (!existListeners) {
      this.listener[type] = []
    }
    this.listener[type].push(cb)
  }
  notify(type) {
    const messages = this.message[type] || []
    const subscribes = this.listener[type] || []
    subscribes.forEach((cb, index) => cb(messages[index]))
  }
}
// 发布者
class Publisher {
  constructor (name, context) {
    this.name = name
    this.context = context
  }
  publish(type, content) {
    this.context.publish(type, content)
  }
}
// 订阅者
class Subscriber {
  constructor (name, context) {
    this.name = name
    this.context = context
  }
  subscribe(type, cb) {
    this.context.subscribe(type, cb)
  }
}

// 实际使用
const TYPE_A = 'music';
const TYPE_B = 'movie';
const TYPE_C = 'novel';

const pubsub = new PubSub();

const publisherA = new Publisher('publisherA', pubsub);
publisherA.publish(TYPE_A, 'we are young');
publisherA.publish(TYPE_B, 'the silicon valley');
const publisherB = new Publisher('publisherB', pubsub);
publisherB.publish(TYPE_A, 'stronger');
const publisherC = new Publisher('publisherC', pubsub);
publisherC.publish(TYPE_C, 'a brief history of time');

const subscriberA = new Subscriber('subscriberA', pubsub);
subscriberA.subscribe(TYPE_A, res => {
  console.log('subscriberA received', res)
});
const subscriberB = new Subscriber('subscriberB', pubsub);
subscriberB.subscribe(TYPE_C, res => {
  console.log('subscriberB received', res)
});
const subscriberC = new Subscriber('subscriberC', pubsub);
subscriberC.subscribe(TYPE_B, res => {
  console.log('subscriberC received', res)
});

pubsub.notify(TYPE_A);
pubsub.notify(TYPE_B);
pubsub.notify(TYPE_C);
~~~

### 设计模式的实际应用

1. vue的响应式原理：