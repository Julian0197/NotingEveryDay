## 3.两栏布局：左边固定，右边自适应 方案越多越好

## 4.手写promise

## 5.请求节流

fetch函数，返回一个promise对象，promise中执行异步操作。异步操作成功时执行resolve结束当前promise状态，后续可以把index传递给then注册的成功的回调函数中，如：`fetch(1,'one').then(() => console.log('成功的index'))`

~~~js
// 模拟请求，无需修改
const now = Date.now()
function fetch(index, type) {
    return new Promise((resolve) => {
		setTimeout(() => {
        	console.log(`[${index}] fetchOnly${type} end at: ${(Date.now() - now)/1000}s`)
        	resolve(index)
        }, (4-index) * 1000)
    })
}

// 场景一：同时只有一个在进行中的请求，一个结束后再进行下一个
const queue = [] // 队列存放请求
function fetchOnlyOne(index) {
    queue.push(index)
    if (queue.length === 1) {
        
    }
    fetch(index, 'one')
}
fetchOnlyOne(1)
fetchOnlyOne(2)
fetchOnlyOne(3)
fetchOnlyOne(4)

// 场景二：假设同时可以有两个请求，要求在尽可能短的时间内完成所有请求该怎么办？
function fetchOnlyTwo(index) {
    fetch(index, 'two')
}
fetchOnlyTwo(1)
fetchOnlyTwo(2)
fetchOnlyTwo(3)
~~~

## 6.动态规划思路总结

- [ ] 爬楼梯II
- [ ] 使用最小花费爬楼梯

- [ ] 不同路径
- [ ] 不同路径II
- [ ] 整数拆分
- [ ] 不同的二叉搜索树

