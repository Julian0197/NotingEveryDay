<h1 align=center>动态规划</h1>

#### 1.斐波那契数

~~~javascript
var fib = function(n) {
    let dp = [0, 1];
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
};
~~~

#### 2.爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。	

~~~javascript
var climbStairs = function(n) {
    //dp[i]表示爬i个楼梯，有多少种方法
    let dp = [1, 2]; // 初始化
    for (let i = 2; i < n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n-1];
};
~~~

#### 3.使用最小花费爬楼梯

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

~~~javascript
var minCostClimbingStairs = function(cost) {
    // dp[i]表示到达i楼梯需要多少体力
    // dp[i] = min(dp[i-1], dp[i-2]) + cost[i],要算上这一层的体力
    // 初始化
    dp = [cost[0], cost[1]];
    for (let i = 2; i < cost.length; i++) {
        dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i];
    }
    // 可以跳两步或者跳一步
    return Math.min(dp[cost.length-1], dp[cost.length-2]);
};
~~~

#### 4.不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

<img src="https://img-blog.csdnimg.cn/20210110174033215.png" alt="img" style="zoom: 47%;" />

~~~javascript
// 1.深度优先搜索：机器人走过的路径可以抽象成二叉树（左子树：向下走 右子树：向右走），叶子节点为终点
var uniquePaths = function(m, n) {
    const dfs = (i, j) => {
        if (i > m || j > n) return 0; // 越界
        if (i === m && j === n) return 1 // 到达叶子节点
        let left = dfs(i+1, j);
        let right = dfs(i, j+1);
        return left + right;
    }
    return dfs(1, 1);
};
~~~

~~~javascript
// 2.深度优先搜索+记忆化：
// 由于dfs(m, n) 和 dfs(n, m)相等，所以一次缓存两个结果 
var uniquePaths = function(m, n) {
    const cache = new Map();
    const dfs = (m, n) => { // 从终点往前搜索
        const keys = [m + '-' + n,n + '-' + m]; // 记录当前位置
        for (const key of keys) { // 查看记录，有记录可以直接返回值，不用递归
            if (cache.has(key)) {
                return cache.get(key);
            }
        }
        let sum = 0; // 每次sum要从0开始
        if (m === 0 && n === 0) return 1; // 找到一种路径
        if (m > 0) sum += dfs(m-1, n);
            
        if (n > 0) sum += dfs(m, n-1);
        for (const key of keys) {
            cache.set(key, sum); // 搜索到底后回溯，把sum赋给所有key
        }
        return sum;
    }
    return dfs(m-1, n-1);
};
~~~

~~~javascript
// 3.数论
// 一共m，n的话，无论怎么走，走到终点都需要 m + n - 2 步。
// 在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。
var uniquePaths = function (m, n) {
    return factorial_recursion (n + m - 2) / (factorial_recursion (n - 1) * factorial_recursion (m - 1));
};
// 阶乘函数
var factorial_recursion = (i) => {
    if (i <= 1) return 1;
    return i * factorial_recursion (i - 1);
}

~~~

~~~javascript
// 4.动态规划
var uniquePaths = function(m, n) {
    // dp[i][j]表示从起点到i，j有多少路径
    const dp = Array(m).fill().map(rowItem => Array(n));

    //初始化
    for (let i = 0; i < m; ++i) dp[i][0] = 1;
    for (let i = 0; i < n; ++i) dp[0][i] = 1;

    for (let i = 1; i < m; ++i) {
        for (let j = 1; j < n; ++j) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
};
~~~

#### 5.不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

~~~javascript
var uniquePathsWithObstacles = function(obstacleGrid) {
    const m = obstacleGrid.length
    const n = obstacleGrid[0].length
    const dp = Array(m).fill().map(item => Array(n).fill(0))
    // 沿一条边，没有碰到障碍物，初始化为1，否则为0
    for (let i = 0; i < m && obstacleGrid[i][0] === 0; ++i) {
        dp[i][0] = 1;
    }  
    for (let i = 0; i < n && obstacleGrid[0][i] === 0; ++i) {
        dp[0][i] = 1;
    }  

    for(let i = 1; i < m; ++i) {
        for (let j = 1; j < n; ++j) {
            if (obstacleGrid[i][j] === 1) {
                dp[i][j] = 0;
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
            
        }
    }
    return dp[m - 1][n - 1]
};
~~~

#### 6.整数拆分

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

~~~javascript
var integerBreak = function(n) {
    let dp = new Array(n + 1).fill(0); // 下标从1开始
    // dp[i]表示拆分i后的数的最大乘积，初始化dp[2]
    dp[2] = 1;
    // dp[i] 可以拆成 j * i - j 或者 j * dp[i-j]
    for (let i = 3; i <= n; i++) {
        for (let j = 1; j < i; j++) {
            dp[i] = Math.max(dp[i], j * (i - j), j * dp[i-j]);
        }
    }
    return dp[n];
};
~~~

#### 7.不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

~~~javascript
// dp[i]表示1到i组成的二叉搜索树的个数
// 递推公式 dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
var numTrees = function(n) {
    let dp = new Array(n+1).fill(0);
    dp[0] = 1;
    dp[1] = 1;
    for (let i = 2; i <=n; ++i) {
        for (let j = 1; j <= i; ++j) {
            // j = 1,最大为i-1，j取i，最大也为i-1
            dp[i] += dp[j-1] * dp[i-j];
        }
    }
    return dp[n];
};
~~~

#### 8.分割等和子集

给定一个只包含正整数的非空数组。是否可以将这个数组分割成==两个==子集，使得两个子集的元素和相等。

注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

示例 1: 输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11].

<img src="https://pic.leetcode-cn.com/1602372398-tqYjTN-image.png" alt="image.png" style="zoom: 31%;" />

~~~~javascript
// 1.回溯
var canPartition = function(nums) {
    let sum = nums.reduce((prev, cur) => prev + cur);
    if (sum % 2 != 0) return false;
    // 目标和
    let target = sum / 2; 
    // 降序排列
    nums.sort((a, b) => b - a);
    // 使用备忘录
    const memo = new Map();
    // curSum为当前累计和，i数字的索引
    const dfs = (curSum, i) => {
        // 递归终止条件，失败
        if (i === nums.length || curSum > target) return false;
        // 递归终止条件，成功
        if (curSum === target) return true;
        // 检查当前key是否在memo中，在的话，可以直接使用
        const key = curSum + '&' + i;
        if (memo.has(key)) return false;
        // 每次递归两种选择，选nums[i]和不选nums[i]
        const res = dfs(curSum + nums[i], i + 1) || dfs(curSum, i + 1);
        // 记录缓存
        memo.set(key, res);
        return res;
    }
    return dfs(0, 0);
};
~~~~

~~~javascript
// 2.动态规划-二维
var canPartition = function(nums) {
    let sum = nums.reduce((prev, cur) => prev + cur);
    if (sum % 2 != 0) return false;
    // 目标和
    let target = sum / 2; 
    // dp[i][j]表示可装物品为0-i，背包容量为j的情况下，背包内容量的最大价值
    // 本题中nums[i]既表示价值，又表示重量，所以当背包容量为j时，能装入的最大价值恰好就是j
    dp = new Array(nums.length).fill().map(item => Array(target + 1).fill(0));
    // 初始化，dp[0][j] = nums[0] if(j > nums[i])
    for (let j = nums[0]; j <= target; j++) {
        dp[0][j] = nums[0];
    }
    // 遍历物品装入背包
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j <= target; j++) {
            // 如果背包可以容纳nums[i]
            if (j >= nums[i]) {
                // 递推公式,从上一个状态推导而来，加入nums[i]或者不加
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i]);
            } else { // 不能容纳nums[i]
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[nums.length-1][target] == target;
};
~~~

~~~javascript
// 3.动态规划-一维
var canPartition = function(nums) {
    let sum = nums.reduce((prev, cur) => prev + cur);
    if (sum % 2 != 0) return false;
    // 目标和
    let target = sum / 2; 
    let dp = new Array(target+1).fill(0);
    for (let i = 0; i < nums.length; i++) {
        for(let j = target; j >= nums[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);
            if (dp[j] == target) return true;
        }
    }
    return dp[target] == target;
};
~~~

#### 9.最后一块石头的重量 II

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

**思路：尽可能将石头分成重量相同的两堆**

~~~javascript
// 一维
var lastStoneWeightII = function(stones) {
    let sum = stones.reduce((pre, cur) => pre + cur);
    // target 向下取整，分成两堆石头，sum-dp[target] >= dp[target]，两者相减为最后剩下的重量
    target = Math.floor(sum / 2);
    let dp = new Array(target + 1).fill(0);
    for (let i = 0; i < stones.length; i++) {
        for (let j = target; j >= stones[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j-stones[i]] + stones[i])
        }
    }
    return sum - 2 * dp[target];  
};
~~~

~~~javascript
// 二维
var lastStoneWeightII = function(stones) {
    let sum = stones.reduce((pre, cur) => pre + cur);
    target = Math.floor(sum / 2);
    // dp[i][j]表示背包容量为j的情况下，选择0-i的物品，最能达到的最大价值
    let dp = new Array(stones.length).fill().map(item => new Array(target + 1).fill(0));
    //初始化
    for (let i = stones[0]; i <= target; i++) {
        dp[0][i] = stones[0];
    }
    for (let i = 1; i < stones.length; i++) {
        for (let j = 1; j <= target; j++) {
            if (j >= stones[i]) {
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i]);
            } else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return sum - 2 * dp[stones.length-1][target];
};
~~~

#### 10.目标和

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

~~~javascript
// 带记忆的深度优先遍历
var findTargetSumWays = function(nums, target) {
    const memo = new Map();
    const dfs = (nums, i, rest) => { 
        // i为当前索引，不断用reset减去值，当等于0说明得到结果
        if (i == nums.length) {
            return rest === 0 ? 1 : 0;
        }
        // memo记录的是当i和rest时候，符合条件的情况个数
        const key = i + '&' + rest;
        if (memo.has(key)) return memo.get(key);
        let res = dfs(nums, i + 1, rest - nums[i]) + dfs(nums, i + 1, rest + nums[i]);
        memo.set(key, res);
        return res;
    }
    return dfs(nums, 0, target);
};
~~~
![image-20220507112001712](C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20220507112001712.png)

~~~javascript
// 动态规划：0-1背包问题，从中选出数字和恰好为pos和neg
var findTargetSumWays = function(nums, target) {
    let sum = nums.reduce((prev, cur) => prev + cur);
    if (Math.abs(target) > sum) return 0;
    if ((target + sum) % 2 !== 0) return 0;
    const cap = Math.min((sum + target) / 2, (sum - target) / 2);
    // dp[j]表示装满容量j有多少种方法
    let dp = new Array(cap + 1).fill(0);
    // 初始化,装满容量为0的背包有1种方法
    dp[0] = 1;
    for (let i = 0; i < nums.length; i++) {
        for (let j = cap; j >= nums[i]; j--) {
            // 填满容量为j - nums[i]的背包，有dp[j - nums[i]]种方法。在当前物品为i的情况下，填满j的背包要加上这么多方法
            dp[j] += dp[j - nums[i]];
        }
    }
    return dp[cap];
};
~~~

#### 11.一和零

给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

~~~javascript
// 0-1背包问题，但是dp数组为二维
// dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。
// 背包重量有两个维度，0和1的可用数量
// 递推公式：dp[i][j] = dp[i - zeroNum][j - oneNum] + 1。
var findMaxForm = function(strs, m, n) {
    const dp = Array.from(Array(m+1), () => Array(n+1).fill(0));
    let numOfZeros, numOfOnes;
    for (let str of strs) { // 这个是外层for循环，遍历字符串
        numOfZeros = 0;
        numOfOnes = 0;
        for (let l of str) {
            if (l === '0') numOfZeros++;
            if (l === '1') numOfOnes++;
        }
        // 内层遍历价值，倒序遍历，避免重复使用元素
        for (let i = m; i >= numOfZeros; i--) {
            for (let j = n; j >= numOfOnes; j--) {
                dp[i][j] = Math.max(dp[i][j], dp[i-numOfZeros][j-numOfOnes] + 1);
            }
        }
    }
    return dp[m][n];
};
~~~

#### 12.零钱兑换 II

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

==需要注意的是，求得是组合数量，不是排列数量。如果外层遍历背包容量，内层遍历硬币数，求得是排列数量。==

~~~javascript
var change = function(amount, coins) {
    const dp = new Array(amount+1).fill(0);
    dp[0] = 1;
    for (let i = 0; i <= coins.length; i++) { // 外层遍历硬币数量
        for (let j = coins[i]; j <= amount; j++) { // 内层遍历背包容量
            dp[j] += dp[j-coins[i]];
        }
    }
    return dp[amount];
};
~~~

#### 13.组合总和 Ⅳ

给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。

**和上题不同，求得是排列数量。如果外层遍历物品，内层遍历重量。**

**举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！**

<img src="https://img-blog.csdnimg.cn/20210131174250148.jpg" alt="377.组合总和Ⅳ" style="zoom:49%;" />

~~~javascript
var combinationSum4 = function(nums, target) {
    const dp = new Array(target + 1).fill(0);
    dp[0] = 1;
    for (let i = 0; i <= target; i++) {
        for (let j = 0; j < nums.length; j++) {
             if (i >= nums[j]) {
                 dp[i] += dp[i-nums[j]]
             }
        }
    }
    return dp[target];
};
~~~

#### 14.爬楼梯（进阶）

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

**改为：一步一个台阶，两个台阶，三个台阶，.......，直到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？**

1阶，2阶，.... m阶就是物品，楼顶就是背包。

每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶

~~~javascript
// dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法。
// 递推公式为：dp[i] += dp[i - j]，dp[0] 一定为1
var climbStairs = function(n) {
    const dp = new Array(n+1).fill(0);
    dp[0] = 1;
    const weight = [1, 2]; // weight就是可以跨的台阶数
    // 求排列数，不是组合数，外层遍历背包容量（楼梯数量）
    for (let i = 0; i <= n; i++) {
        for (let j = 0; j < weight.length; j++) {
            if (i >= weight[j]) {
                dp[i] += dp[i - weight[j]];
            }
        }
    }
    return dp[n];
};
~~~

#### 15.零钱兑换

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 ==最少的硬币个数== 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

~~~javascript
var coinChange = function(coins, amount) {
    if (!amount) return 0;
    // dp[i] 表示凑成i最少的硬币个数，所以除0外初始化要选大的数，不然递推下来都是0
    let dp = new Array(amount + 1).fill(Infinity)
    dp[0] = 0;
    // 这里求得是组合数最小，外层遍历为硬币数量
    for (let i = 0; i < coins.length; i++) {
        for (let j = coins[i]; j <= amount; j++) {
            dp[j] = Math.min(dp[j-coins[i]] + 1, dp[j]);
        }
    }
    return dp[amount] === Infinity ? -1 : dp[amount];
};	
~~~

#### 16.完全平方数

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

**转化为完全背包问题，完全平方数就是背包物品（可以无条件使用），背包容量为n**

~~~javascript
var numSquares = function(n) {
    // 求最少的完全平方数之和，所以除了0，其他初始化为无限大
    let dp = new Array(n + 1).fill(Infinity)
    // 完全平方数从1开始
    dp[0] = 0
    for (let i = 1; i**2 <= n; i++) {
        for (let j = i**2; j <= n; j++) {
            dp[j] = Math.min(dp[j], dp[j - i**2] + 1)
        }
    }
    return dp[n]
};
~~~

#### 17.单词拆分

给你一个字符串 s 和一个字符串列表 **wordDict 作为字典**。请你判断是否可以**利用字典中出现的单词拼接出 s** 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**深度优先搜索：考察所有拆分可能，指针从左向右扫描**

+ **指针左侧是单词，对剩余子串递归考察**

+ **指针左侧不是单词，回溯，考虑别的分支**

  <img src="https://pic.leetcode-cn.com/78fd09b2deabeae972809c2795ddb8be96720b8e62377cf01b7f70e7fb3dbf8c-image.png" alt="image.png" style="zoom:33%;" />

~~~javascript
// 1.dfs深度优先搜索
var wordBreak = function(s, wordDict) {
    let len = s.length
    const wordSet = new Set(wordDict)
    const dfs = (start) => {   // 判断从start到末尾的字符串能否对应wordSet中的单词
        if (start === len) return true // 指针越界，且s成功划分才能走到这一步此时没有剩余字符串，返回true，结束递归
        for(let i = start + 1; i <= len; i++) { // 这里注意是i<=len,因为slice切割是左闭右开的区间
            const prefix = s.slice(start, i) // 切出的前缀部分
            if (wordSet.has(prefix) && dfs(i)) { // 前缀部分在wordset中，继续递归剩余子串，i作为下一个子串的首部，剩余子串能break，返回true
                return true
            } // && 如果前缀不是子串，不会执行dfs(i)。for循环往后迭代，切出另一个前缀，再尝试
        }
        // for循环结束还没有返回true说明，前缀始终不在wordset中，返回false
        return false
    }
    return dfs(0)
};
~~~

上述计算方式，可能会遇到大量重复操作

<img src="https://pic.leetcode-cn.com/5cba31457da78b75f3d593ef6f3c64c34e80db00c5e619f7e03affb1d6b829f0-image.png" alt="image.png" style="zoom:30%;" />

用memo数组记录结果，索引为start，值为返回结果，memo记录的是从start

<img src="https://pic.leetcode-cn.com/2f0982c37f7681f16fe290f89df77660597b828a4038689b563f40eaa4958fa8-image.png" alt="image.png" style="zoom:37%;" />

~~~javascript
var wordBreak = function(s, wordDict) {
    let len = s.length
    const wordSet = new Set(wordDict)
    const memo = new Array(len);
    const dfs = (start) => {
        if (start === len) return true
        if (memo[start] != undefined) return false
        for (let i = start + 1; i <= len; i++) {
            const prefix = s.slice(start, i)
            if (wordSet.has(prefix) && dfs(i)) {
                memo[start] = true;
                return true
            }
        }
        memo[start] = false
        return false
    }
    return dfs(0)
};
~~~
转化为完全背包问题：长度为i 的子串能否由单词表组成

dp[i]表示长度为i，s[0-i-1]子串能否被拆分为单词

s[0:i] 子串对应 dp[i+1] ，它是否为 true（s[0:i]能否 break），取决于两点：
它的前缀子串 s[0:j-1] 的 dp[j]，是否为 true。
剩余子串 s[j:i]，是否是单词表的单词。

<img src="https://pic.leetcode-cn.com/bcef185f09c72fb525855bd56155f4658793d86b0dc4f3de31cace6bd9398c5b-image.png" alt="image.png" style="zoom: 38%;" />

~~~javascript
// 动态规划
var wordBreak = function(s, wordDict) {
    const len = s.length
    const dp = new Array(len+1).fill(false)
    dp[0] = true // 递推公式，dp[0]必须为true
    const wordSet = new Set(wordDict)
    for (let i = 1; i <= len; i++) { // 外层循环遍历字符串
        for (let j = i - 1; j >= 0; j--) { // 内层循环用j切割字符串
            if (dp[j] == false) continue
            const suffix = s.slice(j, i) // 后缀部分
            if (wordSet.has(suffix) && dp[j]) { // 后缀部分是单词且前缀为true
                dp[i] = true
                break // i长度子串能划分单词了，此时跳出内层for循环，外层i往后遍历
            }
        }
    }
    return dp[len]
};
~~~

#### 18.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**dp[i]表示考虑下标i以内的屋子，最多可以偷窃的金额**

**递推公式：偷不偷第i间，偷的话dp[i] = dp[i-2] + nums[i]；不偷的话，dp[i] = dp[i-1]考虑第i-1房间的状态，并不是说一定要偷第i-1间房间**

**初始化：dp[0] = nums[0], dp[1] = max(dp(0), nums[1])**

~~~javascript
var rob = function(nums) {
    const len = nums.length
    const dp = [nums[0], Math.max(nums[0], nums[1])]
    for (let i = 2; i < len; i++) {
        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1])
    }
    return dp[len-1]
};
~~~
#### 19.打家劫舍II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。==所有的房屋都 围成一圈==，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

**思路：**

+ 两种情况：不偷第一间的情况和不偷最后一间的情况
+ 转移方程：已知dp[n]，考虑dp[n+1]；抢第n+1那么不能抢n，不抢就等于dp[n]

~~~javascript
var rob = function(nums) {
    // 如果nums长度只有三个，只需要考虑其中最大的元素
    if(nums.length <= 3) return Math.max(...nums)
    let len = nums.length

    // 考虑第一间，不考虑最后一间
    let dp1 = [nums[0], Math.max(nums[0], nums[1])]
    for (let i = 2; i < len-1; i++) { 
        dp1[i] = Math.max(dp1[i-1], dp1[i-2] + nums[i])
    }

    // 考虑最后一间，不考虑第一间
    let dp2 = [0, nums[1], Math.max(nums[1], nums[2])]
    for (let i = 3; i < len; i++) {
        dp2[i] = Math.max(dp2[i-1], dp2[i-2] + nums[i])
    }

    return Math.max(dp1[len-2], dp2[len-1])
};
~~~
~~~javascript	
// 方法2，完成两个打家劫舍rob[0,1,2,3]和rob[1,2,3,4]
var rob = function(nums) {
    let len = nums.length
    // 如果nums长度不超过3，只需要考虑其中最大的元素
    if(len <= 3) return Math.max(...nums);
    // res1表示不选最后一间
    const res1 = robRange(nums, 0, len-2);
    // res2表示不选第一间
    const res2 = robRange(nums, 1, len-1);
    return Math.max(res1, res2);
};

const robRange = (nums, start, end) => {
    const dp = new Array(nums.length).fill(0)
    dp[start] = nums[start]
    dp[start+1] = Math.max(nums[start], nums[start+1])
    for (let i = start + 2; i <= end; i++) {
        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])
    }
    return dp[end]
};
~~~

#### 20.打家劫舍III

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

**递归，后序遍历，要对递归的返回值做下一步处理**

+ 如果选了当前节点，那么左右孩子都不考虑，可以考虑左右孩子的四个子树
+ 如果没选当前节点，考虑左右孩子，收益是左右子树的收益之和（不一定非要选择一个）

~~~javascript
// 1.递归
var rob = function(root) {
    // 遇到空节点
    if (root === null) return 0
    // 打劫包括根节点的收益,一定包含了root.val
    let roobRoot = root.val;
    if (root.left) {
        roobRoot += rob(root.left.left) + rob(root.left.right)
    }
    if (root.right) {
        roobRoot += rob(root.right.left) + rob(root.right.right)
    }
    // 打劫不包括根节点的收益
    let roobNoRoot = rob(root.left) + rob(root.right)

    return Math.max(roobRoot, roobNoRoot)
};
~~~
上述不带记忆化的递归计算了root的四个孙子子树，又计算了root的左右子树；而后者会重复计算root的孙子子树，因此可以把结果存放到map中
~~~javascript
// 带记忆的递归
var rob = function(root) {
    const memo = new Map()
    const dfs = (root) => {
        if (!root) return 0
        if (memo.has(root)) return memo.get(root)
        let robRoot = root.val;
        if (root.left) {
            robRoot += dfs(root.left.left) + dfs(root.left.right)
        }
        if (root.right) {
            robRoot += dfs(root.right.left) + dfs(root.right.right)
        }
        let robNoRoot = dfs(root.left) + dfs(root.right)
        let res = Math.max(robRoot, robNoRoot);
        memo.set(root, res);
        return res;       
    }
    return dfs(root)
};
~~~

**动态规划**

每个子树有两种状态下的最优解：打劫root和不打劫root

两个变量决定一个状态：是哪个根节点？是否打劫该根节点

没打劫根节点，则左右子树的根节点可打劫可不打劫：
==res[0] = 左子树的两个状态的较大值 + 右子树的两个状态的较大值。==

打劫了根节点，则左右子树的根节点不能打劫：
==res[1] = root.val + 左子树的 [0] 状态 + 右子树的 [0] 状态。==

~~~javascript
var rob = function(root) {
    // dfs返回以root为根节点的所有子树的收益
    const dfs = (root) => {
        // 递归出口，两种状态下收益都是0
        if (!root) return [0, 0]
        // 递归调用左子树
        const left = dfs(root.left)
        // 递归调用右子树
        const right = dfs(root.right)

        // 记录没有打劫当前根节点时候的收益
        //  = 左子树两种状态下最大值 + 右子树两种状态下的最大值
        const DoNot = Math.max(left[0], left[1]) + Math.max(right[0], right[1])
        // 记录打劫过根节点时候的收益
        //  = root.val + 左子树不打劫根节点的收益 + 右子树不打劫根节点的收益
        const Do = root.val + left[0] + right[0]
        return [DoNot, Do]
    }
    const res = dfs(root)
    return Math.max(...res)
};
~~~

#### 21.买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 ==某一天 买入==这只股票，并选择在 ==未来的某一个不同的日子卖出==该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

~~~javascript
// 1.回顾贪心算法
// 只能买一次，卖出一次；贪心：维护最小的买入价格，和在最小价格基础上卖出的最大收益
var maxProfit = function(prices) {
    let low = Infinity;
    let res = 0;
    for (let i = 0; i < prices.length; i++) {
        low = Math.min(low, prices[i])
        res = Math.max(res, prices[i] - low);
    }
    return res;
};
~~~
**动态规划：**

+ dp[i] [0]表示第i天持有股票的总金额，注意是持有不是买入
+ dp[i] [1]表示第i天不持有股票的总金额
+ 递推：dp[i] [0] = 昨天的持有状态 或者 昨天不持有今天买入的状态
+ 递推：dp[i] [1] = 昨天不持有股票 或者 昨天持有股票今天卖掉
+ 初试话dp[0] [1] 和 dp[0] [0]，从前往后遍历 

~~~javascript
// 动态规划
var maxProfit = function(prices) {
    const dp = new Array(prices.length).fill([0, 0])
    dp[0] = [-prices[0], 0]
    for (let i = 1; i < prices.length; i++) {
        // 注意这里，当天买入股票，因为股票全程只能买入一次，所以是-prices[i]
        dp[i][0] = Math.max(dp[i-1][0], - prices[i])
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i])
    }
    return dp[prices.length-1][1]
};
~~~

#### 22.买卖股票的最佳时机II

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地==完成更多的交易==（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须==在再次购买前出售掉之前的股票==）。

**第i天持有股票即dp[i] [0]，昨天不持有股票的所得现金 减去 今天的股票价格 即：dp[i - 1] [1] - prices[i]。**

~~~javascript
var maxProfit = function(prices) {
    let dp = Array.from(Array(prices.length), () => Array(2).fill(0))
    dp[0][0] = -prices[0]
    for (let i = 1; i < prices.length; i++) {
        // 注意这里，股票可以买卖多次！ 所以买入股票的时候，可能会有之前买卖的利润
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i])
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i])
    }
    return dp[prices.length-1][1]
};
~~~

#### 23.买卖股票的最佳时机III

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**动态规划：**

+ 一天共5种状态

1. 没有操作
2. 第一次买入
3. 第一次卖出
4. 第二次买入
5. 第二次卖出

+ dp[i] [j]表示第i天状态j所剩最大现金。

~~~javascript
var maxProfit = function(prices) {
    let dp = Array.from(Array(prices.length), () => Array(5).fill(0))
    dp[0][1] = -prices[0] // 没有操作
    dp[0][3] = -prices[0] // 第二次买入初始化，看dp[1][4]的递推公式要初始化为prices[i]，否则dp[1][4] = prices[1] 而dp[1][4]应该等于0（第一天不会完成第二次卖出擦欧洲）
    for (let i = 1; i < prices.length; i++) {
        dp[i][0] = dp[i-1][0]
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])
        dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1] + prices[i])
        dp[i][3] = Math.max(dp[i-1][3], dp[i-1][2] - prices[i])
        dp[i][4] = Math.max(dp[i-1][4], dp[i-1][3] + prices[i])
    }
    return dp[prices.length-1][4]
}
~~~

#### 24.买卖股票的最佳时机 IV

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 ==k 笔交易==。

注意：你==不能同时==参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**思路:**

+ 状态0表示不操作，状态2k-1表示第k次买入，2k表示第k次卖出
+ dp[i] [j] 表示第i天状态为j，剩余得到钱。
+ 递推公式每次都是取最大的剩余钱，

<img src="https://img-blog.csdnimg.cn/20201229100358221.png" alt="188.买卖股票的最佳时机IV" style="zoom: 50%;" />

~~~javascript
var maxProfit = function(k, prices) {
    if (prices == null || prices.length < 2 || k == 0) {
        return 0;
    }
    // 创建动态数组
    let dp = Array.from(Array(prices.length), () => Array(2*k+1).fill(0))
    // 初始化，不管第几次，现在手头上没有现金，只要买入，现金就做相应的减少。
    // dp[0][j]当j为奇数的时候都初始化为 -prices[0]
    for (let j = 1; j < 2 * k; j += 2) {
        dp[0][j] = 0 - prices[0];
    }
    for (let i = 1; i < prices.length; i++) {
        for (let j = 0; j <= 2 * k; j += 2) {
            dp[i][j+1] = Math.max(dp[i-1][j+1], dp[i-1][j] - prices[i])
            dp[i][j+2] = Math.max(dp[i-1][j+2], dp[i-1][j+1] + prices[i])
        }
    }
    return dp[prices.length-1][2*k]
};
~~~

#### 25.最佳买卖股票时机含冷冻期

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

==卖出股票后，你无法在第二天买入股票== (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

+ **状态0：买入股票状态（不一定是今天买入，可能之前买入的）**
+ **卖出股票状态：**
  + **状态1：两天前就卖出了股票，度过了冷冻期，一直没操作，今天仍保持之前的卖出状态**
  + **状态2：今天卖出股票**
+ **状态四：今天为冷冻期**

~~~javascript
var maxProfit = function(prices) {
    if(prices.length < 2) {
        return 0
    } else if(prices.length < 3) {
        return Math.max(0, prices[1] - prices[0]);
    }

    // 动态规划数组，总共4种状态
    let dp = Array.from(Array(prices.length), () => Array(4).fill(0));
    // 初始化：持有股时一定又买入操作，初试金额为0，一定为负数；其余状态卖出和冷冻期最低收益应该为0
    dp[0][0] = 0-prices[0]

    for (let i = 1; i < prices.length; i++) {
        // 达到买入状态：昨天就已经是买入状态了 或 前一天是冷冻期今天买入 或 前一天早就度过冷冻期保持卖出状态
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][3]-prices[i], dp[i-1][1]-prices[i])

        // 达到度过冷冻期的卖出状态：昨天就已经是卖出状态 或 昨天是冷冻期
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][3])

        // 达到今天卖出股票的状态： 昨天一定为买入股票的状态
        dp[i][2] = dp[i-1][0] + prices[i]

        // 达到冷冻期状态：昨天一定刚卖出股票
        dp[i][3] = dp[i-1][2]
    }
    // 冷冻期、今天卖出、之前卖出都有可能达到最大收益
    return Math.max(dp[prices.length - 1][1], dp[prices.length - 1][2], dp[prices.length - 1][3]);
};
~~~

**考虑空间优化的话**

~~~javascript
var maxProfit = function(prices) {
    if(prices.length < 2) {
        return 0
    } else if(prices.length < 3) {
        return Math.max(0, prices[1] - prices[0]);
    }
    let dp = new Array(4).fill(0)
    dp[0] = 0 - prices[0]
    for (let i = 1; i < prices.length; i++) {
        // 要保存一下dp[0]和dp[1]，不然会影响dp[2]和dp[3]的递归
        let temp0 = dp[0]
        let temp2 = dp[2]
        dp[0] = Math.max(dp[0], dp[1]-prices[i], dp[3]-prices[i])
        dp[1] = Math.max(dp[1], dp[3])
        dp[2] = temp0 + prices[i]
        dp[3] = temp2
    }
    return Math.max(...dp)
};
~~~

#### 26.买卖股票的最佳时机含手续费

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以==无限次==地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

~~~javascript
var maxProfit = function(prices, fee) {
    let dp = new Array(prices.length).fill([0,0])
    dp[0][0] = 0 - prices[0]
    for (let i = 1; i < prices.length; i++) {
        // 买入状态
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] - prices[i])
        // 卖出状态
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] + prices[i] - fee)
    }
    // 加上手续费之后，可能买入状态>卖出状态
    return Math.max(dp[prices.length-1][0], dp[prices.length-1][1])
};
~~~

#### 27.最长递增子序列

给你一个整数数组 nums ，找到其中最长==严格递增==子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

动态规划：

+ dp[i] 表示索引为i之前包括i序列且==以nums[i]为结尾==的严格递增最长子序列的长度
+ 递推：位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值（前提掉件是nums[i]>nums[j]。

~~~javascript
var lengthOfLIS = function(nums) {
    let dp = new Array(nums.length).fill(1)
    let res = 1
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)  
            }
            res = Math.max(res, dp[i])
        }
    }
    return res;
};
~~~

#### 28.最长连续递增序列

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

~~~javascript
var findLengthOfLCIS = function(nums) {
    let dp = new Array(nums.length).fill(1)
    for (let i = 0; i < nums.length - 1; i++) {
        if (nums[i+1] > nums[i]) {
            dp[i+1] = dp[i] + 1
        }
    }
    return Math.max(...dp)
};
~~~

#### 29.最长重复子数组

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

示例：

输入： A: [1,2,3,2,1] B: [3,2,1,4,7] 输出：3 解释： 长度最长的公共子数组是 [3, 2, 1] 。

+ dp[i] [j] 是长度为i，且末尾是A[i-1]的子数组和长度为j，且末尾是B[j-1]的子数组，二者最大公共后缀子数组长度
+ 若A[i-1] != B[j-1] 那么dp[i] [j] = 0,否则dp[i] [j] = dp[i-1] [j-1] + 1
+ 若A[i-1] = B[0] ,那么dp[i] [1]  = dp[i] [0] + 1所以dp[i] [0]初试为0，同理dp[0] [j]初试为0

A 、B数组各抽出一个前缀子数组，单看它们的末尾项，如果它们俩不一样——以它们俩为末尾项形成的公共子数组的长度为0：dp[i][j] = 0
如果它们俩一样，以它们俩为末尾项的公共子数组，长度保底为1——dp[i][j]至少为 1，要考虑它们俩的前缀数组——dp[i-1][j-1]能为它们俩提供多大的公共长度
如果它们俩的前缀数组的「末尾项」不相同，前缀数组提供的公共长度为 0——dp[i-1][j-1] = 0
以它们俩为末尾项的公共子数组的长度——dp[i][j] = 1
如果它们俩的前缀数组的「末尾项」相同
前缀部分能提供的公共长度——dp[i-1][j-1]，它至少为 1
以它们俩为末尾项的公共子数组的长度 dp[i][j] = dp[i-1][j-1] + 1
题目求：最长公共子数组的长度。不同的公共子数组的末尾项不一样。我们考察不同末尾项的公共子数组，找出最长的那个。（注意下图的最下方的一句话）

<img src="https://pic.leetcode-cn.com/af2654586483ed87c39c123a1a4b68130f89581d13c46759a7207aae12429fdc-image.png" alt="image.png" style="zoom:42%;" />

~~~javascript
var findLength = function(nums1, nums2) {
    const m = nums1.length;
    const n = nums2.length;
    const dp = Array.from(Array(m+1), () => Array(n+1).fill(0))
    let res = 0; // 存最长子数组长度
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (nums1[i-1] == nums2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1
            }
            res = Math.max(dp[i][j], res)
        }       
    }
    return res;
};
~~~

#### 30.最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

+ dp[i] [j]表示[0, i-1] 的字符串t1和[0, j-1]的字符串t2的最长公共子序列长度
+ 递推公式如下图

<img src="https://img-blog.csdnimg.cn/20210204115139616.jpg" alt="1143.最长公共子序列" style="zoom: 58%;" />

~~~javascript
var longestCommonSubsequence = function(text1, text2) {
    const m = text1.length;
    const n = text2.length;
    let dp = Array.from(Array(m+1), () => Array(n+1).fill(0))
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i-1] == text2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
};
~~~

#### 31.不相交的线

我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。

现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。

以这种方法绘制线条，并返回我们可以绘制的最大连线数。

<img src="https://img-blog.csdnimg.cn/2021032116363533.png" alt="1035.不相交的线" style="zoom:50%;" />

**线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序。**

**转化为求两个字符串的最长公共子序列长度**

dp[i] [j]表示[0, i-1] 的字符串t1和[0, j-1]的字符串t2的最长公共子序列长度

~~~javascript
var maxUncrossedLines = function(nums1, nums2) {
    const m = nums1.length
    const n = nums2.length
    let dp = Array.from(Array(m+1), () => Array(n+1).fill(0))
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (nums1[i-1] === nums2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])
            }
        }
    }
    return dp[m][n]
};
~~~

#### 32.最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

~~~javascript
// 解法1：回顾贪心算法
// 局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。
var maxSubArray = function(nums) {
    let res = -Infinity
    let count = 0
    for (let i = 0; i < nums.length; i++) {
        count += nums[i]
        if (count > res) res = count
        if (count < 0) count = 0
    }
    return res
};
~~~

~~~javascript
// 解法2：动态规划
// dp[i]表示索引i之前的最大子序列之和
// 递推：dp[i]由dp[i-1]+nums[i] 或者 nums[i]推出
// nums[i] 表示从头开始计算当前连续子序列之和
var maxSubArray = function(nums) {
    let dp = new Array(nums.length)
    dp[0] = nums[0]
    let max = dp[0]
    for (let i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i-1] + nums[i], nums[i])
        max = Math.max(max, dp[i])
    }
    return max
};
~~~

#### 33.判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

示例 1： 输入：s = "abc", t = "ahbgdc" 输出：true

~~~javascript
var isSubsequence = function(s, t) {
    const m = s.length
    const n = t.length
    // dp[i][j]表示以索引i-1结尾为下标的s，和以索引t-1结尾为下标的t，相同子序列的长度
    // 根据递推公式, dp[0][0]和dp[i][0]需要初始化为0
    let dp = Array.from(Array(m+1), () => Array(n+1).fill(0))
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s[i-1] === t[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1
            } else { // 相当于t要删除当前元素，继续向后遍历字符串t
                dp[i][j] = dp[i][j-1]
            }
        }
    }
    return dp[m][n] === m
};
~~~

#### 34.不同的子序列

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。

![image.png](https://pic.leetcode-cn.com/1615916797-rXJnAT-image.png)

~~~javascript
// 解法1：带记忆化的递归回溯
var numDistinct = function(s, t) {
    // 目标是从s中挑选能匹配t的个数
    const m = s.length
    const n = t.length
    let memo = Array.from(Array(m), () => Array(n).fill(-1))
    const dfs = (i, j) => { // i是s的索引，j是t的索引
        // j<0,说明t已经匹配完毕，找到一种，返回1
        if (j < 0) return 1
        // i<0，说明s遍历完，并未找到能匹配t的子串，返回0
        if (i < 0) return 0
        // 不等于-1，说明已经有这种情况，直接返回memo的结果
        if (memo[i][j] !== -1) return memo[i][j]

        // 从后向前递归，末尾项相同，有两种选择
        if (s[i] == t[j]) {
            memo[i][j] = dfs(i-1, j) + dfs(i-1, j-1)
        } else { // 不相等，j不能向前移动
            memo[i][j] = dfs(i-1, j)
        }
        return memo[i][j]
    }
    return dfs(m-1, n-1)
};
~~~

~~~javascript
// 解法2：动态规划
// dp[i][j]表示s中0-i-1索引的子串，出现t从0到j-1索引子串的次数；即前i个字符的s子串中，出现t中前j个字符的个数
// 递推公式和回溯一样
// 根据递推公式初试化：dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; 和 dp[i][j] = dp[i - 1][j]; 中可以看出dp[i][0] 和dp[0][j]是一定要初始化的。
// dp[i][0] = 1, dp[0][j] = 0, dp[0][0] = 1
var numDistinct = function(s, t) {
    // 目标是从s中挑选能匹配t的个数
    const m = s.length
    const n = t.length
    let dp = Array.from(Array(m+1), () => Array(n+1).fill(0))   
    for (let i = 0; i <= m; i++) {
        dp[i][0] = 1
    }
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s[i-1] == t[j-1]) {
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
            } else {
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[m][n]
};
~~~

#### 35.两个字符串的删除操作

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

~~~javascript
var minDistance = function(word1, word2) {
    let dp = Array.from(Array(word1.length+1), () => Array(word2.length+1).fill(0))
    for (let i = 1; i <= word1.length; i++) dp[i][0] = i
    for (let i = 1; i <= word2.length; i++) dp[0][i] = i
    for (let i = 1; i <= word1.length; i++) {
        for (let j = 1; j <= word2.length; j++) {
            if (word1[i-1] == word2[j-1]) {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + 1
            }
        }
    }
        return dp[word1.length][word2.length]
}
~~~

#### 36.编辑距离

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

~~~javascript
// 动态规划
// dp[i][j]表示word1中前i个字符串要转化为word2中前j个字符串的最小步骤
// 递推：1.word1删除正在遍历的不相等的字符 2.word2删除正在遍历的不相等的字符（相当于给word1添加该不相等的字符 3.替换元素相当于在word1和word2都删除一个元素的基础上增加一步操作
// 初始化：dp[0][j]相当于word1前0个字符串操作变为word2中前j个字符串，等于j；同理dp[i][0] = i
var minDistance = function(word1, word2) {
    const m = word1.length
    const n = word2.length
    let dp = Array.from(Array(m+1), () => Array(n+1).fill(0))
    for (i = 1; i <= m; i++) dp[i][0] = i
    for (j = 1; j <= n; j++) dp[0][j] = j

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (word1[i-1] == word2[j-1]) {
                dp[i][j] = dp[i-1][j-1]
            } else {
                let add = dp[i-1][j] + 1
                let cut = dp[i][j-1] + 1
                let replace = dp[i-1][j-1] + 1
                dp[i][j] = Math.min(add, cut, replace)
            }
        }
    }
    return dp[m][n]
};
~~~

#### 37.回文子串

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

示例 1：

输入："abc" 输出：3 解释：三个回文子串: "a", "b", "c"

**动态规划：**

+ dp[i] [j]表示区间[i,j]的子串是否是回文子串
+ 递推公式：当s[i] != s[j] 直接返回false， 若s[i] = s[j]有以下三种情况
  + 情况1：i=j，只有一个字符，返回true
  + 情况2：i与j只相差1，例如aa，返回true
  + 情况3： i和j相差大于1时候，要看[i+1,j-1]是不是回文子串

==红色为计算方向，所以递推时，推dp[i] [j]时候dp[i+1] [j-1]已知==

==那么下图遍历顺序应该遵循：j从0到末尾，i从0到j，判断[i,j]==

<img src="https://pic.leetcode-cn.com/17dc7e2a1d0cb9916917e2121ec59d838bc453a4c83df1f60b2f28f10a1f986e-image.png" alt="image.png" style="zoom:56%;" />

~~~javascript
// 解法1：动态规划
var countSubstrings = function(s) {
    let dp = Array.from(Array(s.length), () => Array(s.length).fill(false))
    let count = 0
    for (let j = 0; j < s.length; j++) {
        for (let i = 0; i <= j; i++) {
            if (s[i] === s[j]) {
                if ((j - i) < 2) {
                    dp[i][j] = true
                } else {
                    dp[i][j] = dp[i+1][j-1]
                }
                count += dp[i][j] ? 1 : 0 // dp[i][j]为true就+1
            }
        }
    }
    return count
};
~~~
==把上图的表格横向压扁，竖向一列看作一维数组，还是原来的扫描方向。一维表格中的格子在迭代中更新。==

**当 j - i > 1时，dp[i] 应该由dp[i + 1]推出，此时dp[i] 实际表示[i,j]是不是回文子串，而dp[i+1] 在上一步已经算出表示的是[i+1, j-1]是不是回文子串**

~~~javascript
// 解法二：动态规划，一维，优化空间
var countSubstrings = function(s) {
    const len = s.length
    let count = 0
    let dp = new Array(len)
    for (let j = 0; j < len; j++) {
        for (let i = 0; i <= j; i++) {
            if (s[i] == s[j] && ((j-i) < 2 || dp[i+1])) {
                dp[i] = true
                count++
            } else {
                dp[i] = false
            }
        }
    }
    return count
};
~~~
**比如对一个字符串 ababa，选择最中间的 a 作为中心点，往两边扩散，第一次扩散发现 left 指向的是 b，right 指向的也是 b，所以是回文串，继续扩散，同理 ababa 也是回文串。**

**这个是确定了一个中心点后的寻找的路径，然后我们只要寻找到所有的中心点，问题就解决了。**

**中心点一共有多少个呢？看起来像是和字符串长度相等，但你会发现，如果是这样，上面的例子永远也搜不到 abab，想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串 abab，就可以有中心点 ba 扩展一次得到，所以最终的中心点由 2 * len - 1 个，分别是 len 个单字符和 len - 1 个双字符。**

**如果上面看不太懂的话，还可以看看下面几个问题：**

**为什么有==2 * len - 1== 个中心点？**
**aba 有5个中心点，分别是 a、b、c、ab、ba**
**abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba**
**什么是中心点？**
**中心点即 left 指针和 right 指针初始化指向的地方，可能是一个也可能是两个**
**为什么不可能是三个或者更多？**
**因为 3 个可以由 1 个扩展一次得到，4 个可以由两个扩展一次得到**

~~~javascript
// 解法3：双指针，中心扩展法
var countSubstrings = function(s) {
    const len = s.length
    let count = 0
    for (let i = 0; i < 2 * len - 1; i++) {
        //left和right分别是中心点
        // left是中心点的一半。当i为奇数right=left+1，中心点有两个元素；当i为偶数，中心点只有一个元素
        let left = Math.floor(i/2)
        let right = left + i % 2

        // 由中心点向两边扩散，判断是否是回文子串
        while (left >= 0 && right < len && s[left] == s[right]) {
            count++
            left--
            right++
        }
    }
    return count
};
~~~

#### 38.最长回文子串序列

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

示例 1: 输入: "bbbab" 输出: 4 一个可能的最长回文子序列为 "bbbb"。

==回文子串是要连续的，回文子序列可不是连续的==

**动态规划：**

+ dp[i] [j] 表示字符串s在[i,j]内的最长回文子序列的长度

+ 递推：

  + s[i] = s[j] 长度在原来基础上加2
  + 如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。

+ 初始化：

  + dp[i] [j] = dp[i + 1] [j - 1] + 2 无法计算i = j的情况，i等于j时长度为1
  + 其他情况初试化为0

+ 遍历顺序：从递推公式可以看出，==dp[i[j]是依赖于dp[i + 1] [j - 1] ， dp[i + 1] [j]，dp[i] [j - 1]==，下图红色箭头为推导方向，所以遍历i要从下到上遍历（从len-1往前遍历）。i代表区间左侧，j代表区间右侧，

  <img src="https://pic.leetcode-cn.com/3e044efa067077b64cf08c393e29d4025f26aa46eba1727c8948f3c0035a03da.jpg" alt="img" style="zoom:40%;" />

  **为了保证每次计算 `dp[i][j]`，左下右方向的位置已经被计算出来，只能斜着遍历或者反着遍历**：

  <img src="https://pic.leetcode-cn.com/1600677121-aGPcPu-file_1600677121456" alt="img" style="zoom:40%;" />

  ~~~javascript
  var longestPalindromeSubseq = function(s) {
      const len = s.length
      let dp = Array.from(Array(len), () => Array(len).fill(0))
      for (let i = 0; i < len; i++) {
          dp[i][i] = 1
      }
      for (let i = len - 1; i >= 0; i--) {
          for (let j = i + 1; j < len; j++) {
              if (s[i] == s[j]) {
                  dp[i][j] = dp[i+1][j-1] + 2
              } else {
                  dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])
              }
          }
      }
      return dp[0][len-1]
  };
  ~~~

  
