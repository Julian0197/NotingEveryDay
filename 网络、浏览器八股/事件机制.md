# 事件循环机制

## 对事件循环机制的理解

JS是单线程的，当遇见异步任务时，等待异步任务执行完成会浪费大量时间。所以将异步任务交给任务队列中，当主线程将执行栈中所有代码执行完毕，主线程会去查看任务队列是否有任务，将其取出执行。整个过程称为事件循环机制。

由于所有任务的优先级不同，任务分为**宏任务**和**微任务**，这种设计是为了给紧急任务插队的机会，否则新入队的任务永远被放在队尾。

> 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。所以有些时候也有人将同步代码看成一个宏任务。

**事件循环机制主要用于管理异步回调函数什么时候回到主线程中执行**

**宏任务**

+ setTimeout、setInterval
+ setImmediate(node独有)
+ DOM事件、AJAX事件
+ script（整体代码）

### 对setTimeout和setInterval的理解
setInterval创建一个定时器，每隔一段时间重复执行回调函数。
setTimeout和setInterval定时器都容易产生内存泄露：定时器函数作用域对回调函数有引用，定时器不删除，函数不会被垃圾回收。

一定要使用`clearTimeout`或者`clearInterval`清除定时器。不能仅仅使用`timer = null`来清除定时器。因为定时器执行时候，又会被浏览器的定时器模块引用。


**微任务**

+ process.nextTick(node 独有 与普通微任务有区别，在微任务队列执行之前执行)
+ Promise的一些方法（then）
+ Async/Await(实际就是promise)
+ MutationObserve（h5新特性）

## 浏览器的事件循环机制

1. 首先执行同步任务
1. 当执行完所有同步任务，执行栈为空，检查任务队列是否有异步任务
1. 异步任务分为宏任务和微任务，先执行微任务
1. 执行完微任务后，有必要情况会执行DOM的渲染
1. 开启下一轮EventLoop，也就是执行宏任务中的代码

DOM的修改不会立马导致渲染，**渲染线程和Javascript线程是互斥的**，必须等待Javascript的这次调度执行完或线程挂起了，才能执行渲染。

## Node的事件循环机制

**Node和浏览器是不同的JS执行环境**

1. V8引擎负责解析和执行JS代码
2. 内置API是由运行环境提供的特殊接口，只能在所属的运行环境被调用

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20220926103425118.png" alt="image-20220926103425118" style="zoom:33%;" />