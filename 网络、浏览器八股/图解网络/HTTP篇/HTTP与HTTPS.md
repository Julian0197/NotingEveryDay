### HTTP与HTTPS

#### HTTP与HTTPS有哪些区别

+ HTTP是超文本传输协议，明文传输不安全。HTTPS解决了HTTP不安全的问题，在TCP和HTTP网络层加入了SSL/TLS安全协议，使得报文可以加密传输。
+ HTTP建立连接相对简单，在TCP三次握手后可以进行HTTP传输，而HTTPS在TCP三次握手的基础上还需要SSL/TLS握手，才可以加密传输。
+ 默认端口不一样，HTTP是80，HTTPS是443
+ HTTPS协议需要向CA（证书权威认证）申请数字证书，来保证服务器的身份是可信的。

#### HTTPS解决了HTTP哪些问题

HTTP由于是明文传输，在安全上可能会存在：**被窃听（账号密码），被篡改（添加小广告），被冒充（假淘宝）**。

HTTPS在HTTP层和TCP层中间加入了`SSL/TLS`协议，可以很好地解决上述风险：

+ 信息加密：加密传输无法窃取
+ 校验机制：不能篡改信息
+ 身份证书：证明是官方网站

HTTPS如何解决？

+ **混合加密**保证了信息机密性
+ **摘要算法**实现**完整性**，为数据生成独一无二的**指纹**，指纹用来检验数据的完整性，防止篡改
+ 服务器公钥放入**数字证书**中，解决了窃听的风险

1. **混合加密**

HTTPS采用**对称加密**和**非对称加密**的**混合加密**方式：

> 对称加密：用一个公钥进行加密和解密，问题在于服务器把公钥发送给客户端的过程中存在风险。
>
> 因此，先使用非对称加密（有一对公钥和私钥），服务器存放私钥，将公钥发送给客户端，客户端对数据用公钥加密，但是解密只能使用私钥解密，这样不存在信息泄露风险。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221102142041244.png" alt="image-20221102142041244" style="zoom: 33%;" />

+ HTTPS先采用非对称加密，安全交换`会话秘钥`，这个后续不再使用非对称加密
+ 通信过程中采用对称加密，刚刚安全交换的会话秘钥就是公钥

这样即可以保证传输速度，又可以保证传输安全，因为：

+ 对称加密只有一个秘钥，运算速度快，但是秘钥必须保密不安全
+ 非对称加密安全，有公钥和私钥，公钥任意发放私钥自己保存，但是运算速度满

2. **摘要算法 + 数字签名**

为了保证数据的完整性，也就是传输过程中数据不会被篡改，使用摘要算法。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221102143856092.png" alt="image-20221102143856092" style="zoom:33%;" />

发送方用摘要算法（也就是哈希函数）根据传输数据计算出哈希值A（被称为指纹），这个指纹是唯一的，哈希函数不可逆，也就无法通过哈希值倒推出数据；接收方在收到数据后对数据再做一次哈希运算，比较计算得出的哈希值B和哈希值A，结果相同就证明传来的数据完整的。

**注意：**上述情况，如果传输过程中将数据和哈希值全部替换的话，接收方也会收到假数据，所以在此基础上又使用了非对称加密。

> 补充非对称加密：私钥自己管理，公钥随意发放，而且公钥和私钥可以双向解密（就是用公钥加密，私钥可以解密；私钥加密，公钥也可以解密）
>
> 但是这两种方式的用途不同：
>
> + 公钥加密 + 私钥解密：公钥是可以随意发放的，但是只能用私钥解密，也就是保证了**数据传输的安全**，只有真正的接收方（有私钥的服务器）才可以正确接收到数据。
> + 私钥加密 + 公钥解密：私钥不可泄露，私钥加密后，别人无法用其他数据替换这个数据，因为别人没有私钥，如果接收方能用公钥正确解析出数据，说明**传输过程中数据没有被替换**，因为被替换的数据无法用公钥解密。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221102144900091.png" alt="image-20221102144900091" style="zoom:33%;" />

所以，先对数据哈希运算，计算得出哈希值A后用私钥加密，得到**数字签名**，把数据和数字签名一同发送给接收方，接受方先对数据进行哈希运算得到哈希值B，再对数字签名用公钥解密：1）首先数字签名能用公钥解密确保了整个数据和哈希值A没有被替换。2）哈希值B和公钥解密后的数字签名相同又确保了数据的没有被篡改

3. **数字证书**

前面通过哈希算法确保了数据的完整性，又通过哈希算法和数字签名确保了数据的完整性和不被篡改。但是实际中，**公钥有可能是伪造**的，没有身份验证，服务器伪造，发送公钥，依然功亏一篑。

所以，网站在使用HTTPS之前，需要向 **CA** 申请颁发**数字证书**，数字证书有**证书持有者信息和证书持有者的公钥**。

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221103105827856.png" alt="image-20221103105827856" style="zoom:35%;" />

CA 负责颁发证书以及验证证书的合法性。客户端拿到服务器的证书后，需要验证证书编号是否能在对应的CA机构查到，还要验证证书中的域名和当前访问的域名是否一致，并可以拿到服务器的公钥进行对称加密。

为了防止证书伪造，需要加工数字证书成为**数字签名**。

下图中左侧是数字签名的制作过程，右侧是验证过程

<img src="C:\Users\MSK\AppData\Roaming\Typora\typora-user-images\image-20221103110631037.png" alt="image-20221103110631037" style="zoom:33%;" />

> 下面是HTTPS的详细过程

#### HTTPS如何建立连接，期间交互了什么？

SSL/TLS 协议基本流程：

+ 客户端向服务端索要服务器的公钥
+ 双方通过服务器的公钥和私钥协商获得会话秘钥，这一步也叫做非对称加密
+ 后续通过会话秘钥进行加密通信，这一步叫做对称加密

前两步是 SSL/TLS 的建立过程，也就是TLS握手阶段。

TLS 的握手阶段涉及四次通信，涉及不同的秘钥交换算法，TLS的具体流程也会有不同，现在的秘钥交换算法有`RSA`和`ECDHE`。

详见RSA握手解析。

#### HTTPS的应用数据如何保证完整性？

TLS 在实现上分为**握手协议**和**记录协议**两层：

- TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；

TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE.png" alt="img" style="zoom:33%;" />

具体过程如下：

- 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。
- 接下来，经过压缩的片段会被**加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。
- 再接下来，经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。

#### HTTPS一定安全可靠么

这个问题的场景是这样的：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/https%E4%B8%AD%E9%97%B4%E4%BA%BA.drawio.png" alt="img" style="zoom: 50%;" />

具体过程如下所示：

+ 客户端向服务器发起HTTPS建立连接请求，被假基站转发到了中间人服务器，接着中间人向服务器发起HTTPS建立连接请求，此时客户端和中间人进行TLS握手，中间人和服务器进行TLS握手。
+ 客户端与中间人进行TLS握手，中间人发送自己的公钥证书给客户端，客户端验证证书的真伪，然后从证书拿到公钥，期间生成三个随机数，并且上述过程都采用非对称加密传递数据，根据随机数生成会话秘钥，后续基于会话秘钥进行对称加密传输数据。
+ 同理，服务端也完成了和中间人的TLS四次握手
+ 在后续的通信过程中，中间人能拿着客户端的数据，从服务端获取相应数据

但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。

中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E8%AF%81%E4%B9%A6%E5%AE%89%E5%85%A8%E6%8F%90%E7%A4%BA.png)

如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。

所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS ，得怪自己手贱。

另外，如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。

这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。

所以，**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

> 为什么抓包工具能截取 HTTPS 数据？

很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与中间人一致的。

对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理:

1. 中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；
2. 中间人，作为服务端与真实客户端建立连接，这里会有客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；

中间人要拿到私钥只能通过如下方式：

1. 去网站服务端拿到私钥；
2. 去CA处拿域名签发私钥；
3. 自己签发证书，切要被浏览器信任；

不用解释，抓包工具只能使用第三种方式取得中间人的身份。

使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。

抓包工具能够抓包的关键是客户端会往系统受信任的根证书列表中导入抓包工具生成的证书，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

> 如何避免被中间人抓取数据？

我们要保证自己电脑的安全，不要被病毒乘虚而入，而且也不要点击任何证书非法的网站，这样 HTTPS 数据就不会被中间人截取到了。

当然，我们还可以通过 **HTTPS 双向认证**来避免这种问题。

一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/http/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81.png)

如果用了双向认证方式，不仅客户端会验证服务端的身份，而且服务端也会验证客户端的身份。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。

#### CA证书被伪造了怎么办？

先讲中间人攻击

如果CA证书和要访问的网站一模一样，谷歌提出了**证书透明度技术**，能发现证书签发的全部过程（证书链），其中一旦有伪造证书，可以联系CA机构快速吊销。浏览器能够审计证书的使用情况，如果发现有恶意证书，可以快速关闭HTTPS连接。

谷歌推出的`Except-CT`HTTP头部字段，`Expect-CT` `CT` 头部允许站点选择报告或强制执行证书透明度要求，站点启用时，浏览器会检查该站点使用的证书是否在公共CT日志中。