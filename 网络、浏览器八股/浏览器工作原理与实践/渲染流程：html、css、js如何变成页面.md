## 渲染流程

按照渲染的时间顺序，渲染可分为：构建 DOM 树，样式计算，布局阶段，分层，绘制，分块，光栅化和合成。

### 构建 DOM 树

浏览器无法直接使用 HTML，需要将 HTML 转化为浏览器可以理解的结构 —— DOM 树。

DOM 内容和 HTML 几乎一样，但是 DOM 是保存在内存中的树结构，可以通过 JS 来查询或修改内容：`document.getElementsByTagName("p")[0].innerText = "black"`

### 样式计算

#### 1.转化 CSS => styleSheets

CSS 样式来源：

1. 通过 link 引用外部 CSS 文件
2. <style> 标签内的 CSS
3. 行内样式，元素 style 属性内的 CSS

浏览器也无法直接理解 CSS，渲染引擎会将 CSS 文件解析为浏览器可以理解的结构 —— styleSheets

在控制台输入`document.styleSheets`能看到，同样可以查询和修改。

#### 2.转化样式表属性，标准化

```css
body {
  font-size: 2em;
}
p {
  color: blue;
}
span {
  display: none;
}
div {
  font-weight: bold;
}
div p {
  color: green;
}
div {
  color: red;
}
```

将上述属性，如：`2em、blue、bold`转化为渲染引擎可以理解的标准化的计算值。

转化后：

```css
body {
  font-size: 32px;
}
p {
  color: rgb(0, 255, 255);
}
span {
  display: none;
}
div {
  font-weight: 700;
}
div p {
  color: rgb(0, 128, 0);
}
div {
  color: rgb(255, 0, 0);
}
```

#### 3.计算 DOM 树中每个节点的具体样式

涉及到：**CSS 继承规则和层叠规则**

- CSS 继承：每个 DOM 节点都包含父节点的样式
- 样式层叠：配置优先规则，合并多个源的属性值的算法

样式计算阶段为了计算出 DOM 节点每个元素的具体样式，结果保存在 ComputedStyle 中。

### 布局阶段

布局：计算 DOM 树中可见元素的几何位置

#### 1.创建布局树

DOM 中存在很多不可见元素（`head`标签，`display:none`元素），在显示前需要额外构建一棵只包含可见元素的布局树。

构建布局树，浏览器大体上完成了下面这些工作：

- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
- 而不可见的节点会被布局树忽略掉，
  - 如 head 标签下面的全部内容
  - 再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

#### 2.布局计算

根据完整的布局树计算布局树节点的坐标位置。

### 分层

> 现在已经有了布局树，以及每个元素的具体位置信息，但还是不能立刻绘制页面，为什么？

页面中有很多复杂的效果，如：3D 变换，页面滚动，或者使用 z-indexing 做 z 轴排序等。
为了实现这些效果，渲染引擎还需要为特定的节点生成专用图层，并生成一棵对应的**图层树**。

渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面。

> 满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于**父节点的图层**。

1. 拥有**层叠上下文**属性的元素会被提升为单独的一层

  + 层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上
  + 层叠上下文：定位，透明，CSS滤镜的元素（如：`position: fixed`,`z-index: 2`, `opacity: 0.5`, `filter: blue(5px)`）

2. 需要裁剪（clip）的地方也会被创建为图层

  + 裁剪指的是超出元素范围的文字内容，通常和`overflow`有关系。
  + 出现裁减，渲染引擎会给所有文字部分单独创建一个层
  + 出现滚动，滚动条也会被单独提升为一个层

### 图层绘制

完成图层树的构建后，渲染引擎会对图层树中的每个图层进行绘制。

+ 把一个图层的绘制拆分成很多小的**绘制指令**，然后再把这些指令按照顺序组成一个待绘制列表
+ 图层绘制阶段并不是真的绘制出图层，而是生成图层的绘制列表，然后将该绘制列表作为输入交由下一阶段

### 栅格化

栅格化:将图块转化为位图； 图块是栅格化的最小单位

当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给**合成线程**

+ 通常页面很大,用户只能看见一部分,如果一下子绘制出所有图层,开销很大,所以**合成线程会将图层划分为图块**
+ 然后将视口(用户可见部分)附近图块优先生成位图,实际生成位图的操作由栅格化执行
+ 栅格化通常会用GPU进程加速,渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。

### 合成和显示

合成线程是一个独立的线程，前面都是在浏览器渲染进程的主线程上进行的。

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

合成的图层会被提交给浏览器进程，浏览器进程里会执行显示合成(Display Compositor)，也就是将所有的图层合成为可以显示的页面图片。 最终显示器显示的就是浏览器进程中合成的页面图片

### 大总结

完整的渲染流程:
1. 渲染进程将HTMl转化为浏览器能理解的DOM树结构
2. 渲染引擎将CSS转化为浏览器可以理解的styleSheets,计算出DOM节点的样式
3. 创建布局树(可见元素),计算元素的布局信息
4. 对布局树分层,生成分层树(具有层叠样式或裁剪)
5. 为每个图层生成绘制列表(绘制指令构成),并提交给合成线程
6. 合成线程为图层分为图块（栅格化最小单元），并交给GPU进程进行栅格化将图块转化为位图
7. 合成线程发送绘制图块指令给浏览器进程
8. 浏览器进程最后生成页面，展示在显示器上


### 重绘，重排，直接合成阶段

#### 重绘

通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局。

重排会更新完整的渲染流水线，开销很大。

#### 重排

如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了****布局和分层**阶段，所以执行效率会比重排操作要高一些。

#### 直接合成

更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。

使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

**减少重排重绘的方法：**
+ 使用class操作样式，不是频繁操作style（这样多个样式更改会通过一次重排完成）
+ 批量DOM操作
  + 可以使用`Fragment`（vue3中，是一个虚拟包裹元素，也是可以一次性地完成重排重绘）
  + 框架会利用虚拟DOM批量处理DOM更新，减少重绘重排次数
+ Debounce window resize 事件：当窗口大小改变时，浏览器会触发 resize 事件，导致页面进行重排和重绘。使用 debounce 技术可以延迟处理 resize 事件，直到用户完成调整窗口大小，从而减少重排和重绘的频率。
+ 对 DOM 属性的读写要分离：在 JavaScript 中，读取 DOM 元素的属性（如 offsetTop、offsetWidth 等）会导致浏览器进行重排。为了避免多次重排，可以将读取属性的操作集中在一起，然后再进行写操作。
+ will-change transform优化

> 为什么读取DOM元素的属性，也会触发重排？

当你读取某个 DOM 元素的属性时，浏览器需要获取该属性的实际值。然而，有些属性的值并不是简单地从内存中读取，而是需要通过重新计算来获取。例如，`offsetTop` 属性表示元素相对于包含元素的顶部的偏移量，它的值需要根据**元素的位置和父元素的布局**来计算。

#### will-change属性

`will-change`是一个CSS属性，它可以告诉浏览器某个元素将要发生的变化。通过明确指定这些变化，浏览器可以事先分配和优化相应的资源，从而提升渲染的性能。

~~~css
.element {
  will-change: transform;
}
~~~

使用will-change可以带来以下优化效果：

+ 减少渲染阻塞：浏览器可以提前分配和优化资源，减少渲染阻塞时间，提高页面的响应速度。
+ 减少重绘和重排：使用 will-change 属性可以将元素放在独立的图层上，减少重排和重绘的次数
+ 硬件加速：某些浏览器对will-change属性会进行硬件加速，进一步提升性能。
