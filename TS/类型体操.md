## 类型体操实战

### 实现 If

实现一个 `IF` 类型，它接收一个条件类型 `C` ，一个判断为真时的返回类型 `T` ，以及一个判断为假时的返回类型 `F`。 `C` 只能是 `true` 或者 `false`， `T` 和 `F` 可以是任意类型。

+ 如何约束泛型为boolean类型？
  + C extends boolean
+ 如何判断当前泛型为true？
  + C extends true

~~~ts
type If<C extends boolean, T, F> = C extends true ? T : F

type A = If<true, 'a', 'b'>  // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
~~~

### 实现 Pick

`Pick<T, K>` ==> 从类型 `T` 中选出属性 `K`，构造成一个新的类型。

复习一下前面知识：

+ ##### `keyof`: 取interface的键后保存为联合类型

+ ###### `in`: 取联合类型的值，主要用于数组和对象的构建

~~~ts
type Pick<T, K extends keyof T> = {
  [P in K]: T[P]
} 

// test
// 从 Todo 中挑出 title和completed
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = Pick<Todo, 'title' | 'completed'>
~~~

### 实现 Exclude

`Exclude<T, K>` => 从类型 `T` 中排除掉指定的类型 `K`

extends 前面的类型如果是联合类型，会进行遍历。

~~~Ts
type Exclude<T, K> = T extends K ? never : T;

// test
// 从B中排除类型A
type A = "a" | "b" | "c" | "d";
type B = "b" | "d" | "e" | "f";
type C = Exclude<A, B>; // "a" | "c"
~~~

### 实现 Partial

将某个类型中每个属性设置为可选属性，这表示这些属性的值可以是 `undefined` 或者省略。

~~~ts
type Partial<T> = {
  [P in keyof T]?: T[P]
}

// test
interface Person {
  name: string;
  age: number;
}

type PartialPerson = Partial<Person>;

let person1: PartialPerson = { name: "Alice" }; // age 是可选属性，值默认为 undefined
let person2: PartialPerson = { }; // name 和 age 都是可选属性，值默认为 undefined
let person3: Partial<Person> = { name: "Bob", age: 20 }; // 和 Person 一样，都是必选属性
~~~

### 实现 Omit

从类型 `T` 中删去指定的属性 `K`

注意：使用`as`可以将一个值断言为特定的类型，类型断言并不会对值进行任何运行时的检查或转换，它只是在编译时告诉编译器如何理解代码。

> 为什么要使用`as`？

`P in keyof T` 是一个类型映射，默认情况，类型映射会将遍历的结果设置为一个新的属性，而不是保留原来属性名，所以需要`as`赋值。
~~~ts
type Omit<T, K> = {
  [P in keyof T as P extends K ? never : P]: T[P]
}

// test
interface Person {
  name: string;
  age: number;
  address: {
    city: string;
    street: string;
  };
}

type PersonNameAndAge = Omit<Person, "address">;
~~~

### 实现 Readonly

用于将某个类型中每个属性设置为只读属性，这表示这些属性的值不能被修改。

使用了 `readonly` 关键字将属性设置为只读属性

~~~ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P]
} 

// test
interface Person {
  name: string;
  age: number;
}

type ReadonlyPerson = Readonly<Person>;

let person: ReadonlyPerson = { name: "Alice", age: 30 };
person.name = "Bob"; // 报错，因为 name 是只读属性
person.age = 40; // 报错，因为 age 是只读属性
person = { name: "Carol", age: 50 }; // 可以修改整体属性值
~~~

> 如果要实现一个`Deep ReadOnly`呢？

~~~ts
// keyof T转化为联合类型，联合类型配合extends会有类似乘法分配律的效果
type DeepReadonly<T> = keyof T extends never
	? T
	: { readonly [K in keyof T]: DeepReadonly<T[K]>}
~~~

### 实现 Required

用于将某个类型的所有可选属性都转换为必选属性。

在属性名前使用 `-?` 符号来将所有属性设置为必选属性。

~~~ts
type Required<T> = {
  [P in keyof T]-?: T[P] 
}

// test
interface Person {
  name?: string;
  age?: number;
}

type RequiredPerson = Required<Person>;

let person: RequiredPerson = { name: "Alice", age: 30 };
person.name = "Carol"; // 正常
person.age = 50; // 正常
person = { }; // 报错，因为 name 和 age 是必选属性
~~~

### 实现数组转对象

将一个元组类型转换为对象类型，这个对象类型的键/值和元组中的元素对应。

+ const说明不能被修改，要用只读修饰符
+ 约束元素里的类型仅能为 string symbol number这三个可以为对象键的类型
+ `[K in T[number]]` 对数组里每个index进行循环将index转换成key

~~~ts
type TupleToObject<T extends readonly (string | symbol | number)[]> = {
  [P in T[number]]: P
}

// test
 const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

const result: TupleToObject<typeof tuple> 
// expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}

~~~

### 数组的第一个元素

~~~ts
type First<T extends any[]> = T extends [infer First, ...infer Rest] ? First : never

// test
type arr1 = ["a", "b", "c"];
type arr2 = [3, 2, 1];
type head1 = First<arr1>;
type head2 = First<arr2>;
type t1 = First<[]>;
~~~

### 实现数组的Unshift

~~~ts
// 将元素添加到数组头部
type Unshift<T extends any[], U> = [U, ...T]

// test
type Result = Unshift<[1, 2], 0> // [0, 1, 2];
~~~

### 实现数组的push

~~~ts
// 将元素添加到数组尾部
type Unshift<T extends any[], U> = [...T, U]

// test
type Result = Unshift<[1, 2], 0> // [1, 2, 3];
~~~

### 返回函数的Parameters

+ 使用infer表示待推断的类型变量。
+ 由于...args本身已经是元组类型，因此infer P最终推导出的，也是元组类型。

~~~ts
type Parameters<T extends (...args: any[]) => any> = T extends (...args: infer P) => unknown ? P : never

// test
const foo = (arg1: string, arg2: number): void => {}

type FunctionParamsType = Parameters<typeof foo> // [arg1: string, arg2: number]
~~~

### 实现数组的concat

~~~ts
type Concat<T extends any[], U extends any[]> = [...T, ...U]

// test
type Result = Concat<[1], [2]>; // [1, 2]
~~~

### 实现Trim 处理字符串前后的空格、换行

~~~Ts
type Trim<T extends string> = T extends `${' ' | '\n' | '\t'}${infer U}${' ' | '\n' | '\t'}` ? Trim<U> : T 

// test
type trimmed = Trim<'  Hello World  '> // expected to be 'Hello World'
type c = Trim<'   \n\t foo bar \t'>  // 'foo bar'
~~~

### 判断元祖长度

~~~ts
//判断元组的长度
type Length<T extends any[]> = T["length"]

// test
type tesla = ["tesla", "model 3", "model X", "model Y"];
type spaceX = [
  "FALCON 9",
  "FALCON HEAVY",
  "DRAGON",
  "STARSHIP",
  "HUMAN SPACEFLIGHT"
];
type teslaLength = Length<tesla>; // expected 4
type spaceXLength = Length<spaceX>; // expected 5
~~~

### 推断函数返回类型

不使用 ReturnType 实现 TypeScript 的 ReturnType<T> 泛型。

~~~ts
type ReturnType<T extends Function> = 
  T extends (...args: any) => infer R
    ? R
    : never

// test
const fn = (v: boolean) => {
  if (v)
    return 1
  else
    return 2
}

type a = ReturnType<typeof fn> // 应推导出 "1 | 2"
~~~

### 查找类型

根据某个属性在联合类型中查找类型。我们想通过在联合类型Cat | Dog中通过指定公共属性type的值来获取相应的类型。

~~~ts
type LookUp<U, T extends string> = U extends {type: T} ? U : never

// test
interface Cat {
  type: 'cat'
  breeds: 'Abyssinian' | 'Shorthair' | 'Curl' | 'Bengal'
}

interface Dog {
  type: 'dog'
  breeds: 'Hound' | 'Brittany' | 'Bulldog' | 'Boxer'
  color: 'brown' | 'white' | 'black'
}

type MyDog = LookUp<Cat | Dog, 'dog'> // expected to be `Dog`
~~~

### 将类型为字面类型（标签类型）的属性，转换为基本类型

~~~ts
type ToPrimitive<T> = T extends string
  ? string
  : T extends number
  ? number
  : T extends boolean
  ? boolean
  : T extends bigint
  ? bigint
  : T extends symbol
  ? symbol
  : {
      [K in keyof T]: ToPrimitive<T[K]>
    }

// test
type PersonInfo = { name: 'Tom', age: 30, married: false, addr: { home: '123456', phone: '13111111111' } }
// expect
type ToPrimitive<PersonInfo> = { name: string, age: number, married: boolean, addr: { home: string, phone: string } }
~~~
