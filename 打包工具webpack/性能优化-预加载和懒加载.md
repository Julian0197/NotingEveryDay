## 预加载和懒加载

### 预加载

预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。

加载技术会增加服务器的压力，但是用户的体验会比较好，得看实际运用场景。

#### 图片预加载

+ img标签会在Html渲染解析到的时候，如果解析到img中src的值，则浏览器会立即开启一个线程去请求该资源（并行加载，不阻塞html构建）。
+ 所以我们可以先将img标签隐藏但src写上对应的链接，这样皆可以把资源先请求回来了

~~~html
<img src="https://fuss10.elemecdn.com/a/3f/3302e58f9a181d2509f3dc0fa68b0jpeg.jpeg" style="display: none" />  
~~~

#### js预加载

~~~html
<script src="index.js"></script>
~~~

浏览器在解析HTML时，如果遇到一个没有任何属性的script标签，就会暂停解析，先发送网络请求获取该js脚本的代码，然后让主线程让js引擎执行该改吗，执行完毕后再恢复解析。

1. 只包含`async`模式下，请求该脚本的**网络请求是异步的**，不会阻塞浏览器解析HTML。一旦网络请求回来后，如果此时HTML还没有解析完，浏览器会暂停解析，先让JS引擎执行代码，执行完毕后再解析。

所以 async 是不可控的，因为执行时间不确定，你如果在异步 JS 脚本中获取某个 DOM 元素，有可能获取到也有可能获取不到。而且如果存在多个 async 的时候，它们之间的执行顺序也不确定，完全依赖于网络传输结果，谁先到执行谁。

~~~html
<script async src="index.js"></script>
~~~

2. 只包含`defer` 模式下，当浏览器遇到带有 defer 属性的 script 时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器**不会暂停解析并执行 JS 代码**，而是等待 HTML 解析完毕再执行 JS 代码。

如果存在多个 defer script 标签，浏览器（IE9及以下除外）会保证它们**按照在 HTML 中出现的顺序执行**，不会破坏 JS 脚本之间的依赖关系。

~~~html
<script defer src="index.js"></script>
~~~

3. `type = module`

主流浏览器都支持 ESM，但是需要再script标签上加上 `type = module`

浏览器会对其内部的 import 引用发起 HTTP 请求，获取模块内容。这时 script 的行为会像是 `defer` 一样，在**后台下载**，并且等待 DOM 解析完后再执行js代码

~~~html
<script type="module">import { a } from './a.js'</script>
~~~

### 懒加载

#### 图片懒加载

对于一些图片比较多的页面，用户打开页面后，只需要呈现出在屏幕可视区域内的图片，当用户滑动页面时，再去加载出现在屏幕内的图片，以优化页面的加载效果；

实现：页面中的`img`元素，如果没有`src`属性，浏览器就不会发出请求去下载图片，只有通过javascript设置了图片路径，浏览器才会发送请求。懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把正真的路径存在元素的“data-url”（这个名字起个自己认识好记的就行）属性里，要用的时候就取出来，再设置。

+ 如何获取屏幕可视窗口大小
+ 
~~~js
window.innerHeight // 标准浏览器及IE9+ 
document.documentElement.clientHeight // 标准浏览器及低版本IE标准模式
document.body.clientHeight  // 低版本混杂模式
~~~


+ 获取浏览器窗口顶部与文档顶部之间的距离，即**滚动条滚动的距离**

~~~js
window.pagYoffset // 标准浏览器及IE9+
document.documentElement.scrollTop // 兼容ie低版本的标准模式 
document.body.scrollTop // 兼容混杂模式；

// html5新增
// 可以比较初始和停止滚动时top的差距
const { top: newY } = contentRef.current.getBoundingClientRect();
~~~

`getBoundingClientRect` 是一个用于获取指定元素的位置和尺寸信息的方法。它返回一个 DOMRect 对象，其中包含了元素的左上角坐标、宽度、高度等信息。

#### 路由懒加载

在SPA应用中，一个路由对应一个页面，如果我们不做任何处理，项目打包时，所有的页面都会打包成一个文件，当用户去打开首页时，就会去一次性加载所有的资源，这样首页加载就会慢，降低用户体验。

懒加载就是根据`import()`去实现的，调用import()之处，被作为分离模块的起点，意思是，被请求的模块和它引用的所有子模块，会被分离到一个单独chunk中；所以实现懒加载的方法，就是将需要进行懒加载的子模块分离出来，打包成一个单独的文件，这样就不会一次加载所有的资源了；


##### 使用webpack

懒加载本质：**代码分离**，将代码分离到不同的bundle中，然后按需加载或并行加载这些文件。webpack中实现代码分离方式有：入口起点（entry中手动分离），防止重复（去重和分离chunk），动态导入（模块的内联函数来分离代码）

~~~js
const UserDetails = () =>
  import(/* webpackChunkName: "group-user" */ './UserDetails.vue')
const UserDashboard = () =>
  import(/* webpackChunkName: "group-user" */ './UserDashboard.vue')
const UserProfileEdit = () =>
  import(/* webpackChunkName: "group-user" */ './UserProfileEdit.vue')
~~~

+ 在使用 webpack 进行懒加载时，会将懒加载的模块打包成一个单独的文件，并使用 JSONP 技术动态加载该文件。
+ `jsonp`:允许在浏览器中动态创建`<script>`标签，通过向不同域名的服务器请求脚本文件，并在脚本文件中包含回调函数来传递数据，可以绕过浏览器的同源策略，实现在当前页面加载来自不同域名的代码。

注：有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名 chunk

##### 使用vite

在Vite中，你可以在rollupOptions下定义分块：

~~~js
// vite.config.js
export default defineConfig({
  build: {
    rollupOptions: {
      // https://rollupjs.org/guide/en/#outputmanualchunks
      output: {
        manualChunks: {
          'group-user': [
            './src/UserDetails',
            './src/UserDashboard',
            './src/UserProfileEdit',
          ],
        },
      },
    },
  },
})
~~~

#### 组件懒加载

实现原理和路由懒加载是一样的，都是通过import()的方式实现的

假设有两个复杂页面都使用到了同一个组件，项目打包后，发现两个页面均包括了该组件的代码；且该组件又不是一进入页面就触发的，需要一定条件才触发的；这个时候就比较适合使用组件懒加载；即组件懒加载的使用场景有：

+ 该页面文件体积大，导致页面打开慢，可以通过懒加载进行资源拆分，利用浏览器的并行下载提升速度
+ 该组件又不是一进入页面就触发的，需要一定条件才触发的（比如弹窗）
+ 该组件复用性高，很多页面引用，可以理由懒加载单独形成一个文件
+ 其他时候不建议拆分过细，因为会造成浏览器http请求增多；